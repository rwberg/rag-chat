<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
Â  <title>Chatbot Prototype â€” FilingFixer</title>

Â  <style>
Â  Â  :root {
Â  Â  Â  --user: #333333;
Â  Â  Â  --bot: #757575;
Â  Â  Â  --bg: #f6f8fa;
Â  Â  Â  --fg: #333;
Â  Â  Â  --border: #ddd;
Â  Â  }

Â  Â  * { box-sizing: border-box; }

Â  Â  body {
Â  Â  Â  font-family: Arial, Helvetica, sans-serif;
Â  Â  Â  margin: 10px auto;
Â  Â  Â  color: #fff;
Â  Â  }

Â  Â  /* â€”â€”â€”â€”â€” Suggestions strip â€”â€”â€”â€”â€” */
Â  Â  .suggestions-container {
Â  Â  Â  background: var(--bg);
Â  Â  Â  width: 90%;
Â  Â  Â  border: 1px solid var(--border);
Â  Â  Â  border-radius: 8px;
Â  Â  Â  padding: 12px;
Â  Â  Â  margin-bottom: 16px;
Â  Â  }

Â  Â  .suggestions-container p {
Â  Â  Â  margin: 0 0 8px;
Â  Â  Â  font-size: 0.9em;
Â  Â  Â  color: #333;
Â  Â  }

Â  Â  .suggestions {
Â  Â  Â  display: flex;
Â  Â  Â  gap: 8px;
Â  Â  }

Â  Â  .suggestion-item {
Â  Â  Â  background: #fff;
Â  Â  Â  border: 1px solid var(--border);
Â  Â  Â  border-radius: 8px;
Â  Â  Â  padding: 8px 12px;
Â  Â  Â  flex: 1;
Â  Â  Â  font-size: 0.9em;
Â  Â  Â  cursor: pointer;
Â  Â  Â  transition: background 0.2s;
Â  Â  Â  color: #333;
Â  Â  }

Â  Â  .suggestion-item:hover { background: #eef0f3; }

Â  Â  /* â€”â€”â€”â€”â€” Chat window â€”â€”â€”â€”â€” */
Â  Â  #chat-window {
Â  Â  Â  width: 90%;
Â  Â  Â  height: 400px;
Â  Â  Â  border: 1px solid var(--border);
Â  Â  Â  border-radius: 8px;
Â  Â  Â  padding: 16px;
Â  Â  Â  overflow-y: auto;
Â  Â  Â  background: #fff;
Â  Â  }

Â  Â  /* â€”â€”â€”â€”â€” User bubble â€”â€”â€”â€”â€” */
Â  Â  .bubble {
Â  Â  Â  max-width: 80%;
Â  Â  Â  padding: 16px 24px;
Â  Â  Â  border-radius: 16px;
Â  Â  Â  line-height: 1.2;
Â  Â  Â  margin: 12px 0;
Â  Â  Â  white-space: normal;
Â  Â  Â  font-size: 0.95em;
Â  Â  Â  overflow-wrap: anywhere;
Â  Â  Â  word-break: break-word;
Â  Â  }

Â  Â  .user {
Â  Â  Â  margin-left: auto;
Â  Â  Â  background: var(--user);
Â  Â  Â  color: #fff;
Â  Â  Â  border-bottom-right-radius: 4px;
Â  Â  Â  white-space: pre-wrap;
Â  Â  }

Â  Â  /* â€”â€”â€”â€”â€” Assistant response (no bubble) â€”â€”â€”â€”â€” */
Â  Â  .assistant-response {
Â  Â  Â  max-width: 85%;
Â  Â  Â  margin: 12px 0;
Â  Â  Â  color: #333;
Â  Â  Â  line-height: 1.45;
Â  Â  }

Â  Â  /* Typography inside assistant */
Â  Â  .assistant-response p { margin: 0 0 0.65em 0; }
Â  Â  .assistant-response ul,
Â  Â  .assistant-response ol { margin: 0.4em 0 0.8em 1.2em; padding: 0; }
Â  Â  .assistant-response li { margin-bottom: 0.35em; }

Â  Â  /* Header sizing */
Â  Â  .assistant-response h1,
Â  Â  .assistant-response h2,
Â  Â  .assistant-response h3,
Â  Â  .assistant-response h4 {
Â  Â  Â  margin: 0.8em 0 0.35em 0;
Â  Â  Â  line-height: 1.25;
Â  Â  Â  font-weight: 650;
Â  Â  }
Â  Â  .assistant-response h1 { font-size: 1.25em; }
Â  Â  .assistant-response h2 { font-size: 1.12em; }
Â  Â  .assistant-response h3 { font-size: 1.05em; }
Â  Â  .assistant-response h4 { font-size: 1.0em; }

Â  Â  /* Streaming blocks */
Â  Â  .assistant-final { }
Â  Â  .assistant-live { }

Â  Â  /* â€”â€”â€”â€”â€” Typing animation â€”â€”â€”â€”â€” */
Â  Â  @keyframes blink {
Â  Â  Â  0%, 80%, 100% { opacity: 0; }
Â  Â  Â  40% { opacity: 1; }
Â  Â  }

Â  Â  .typing {
Â  Â  Â  display: inline-flex;
Â  Â  Â  gap: 4px;
Â  Â  Â  font-size: 1.4em;
Â  Â  Â  padding: 8px 12px;
Â  Â  Â  border: 1px solid var(--border);
Â  Â  Â  border-radius: 12px;
Â  Â  Â  color: #333;
Â  Â  Â  margin: 8px 0;
Â  Â  }

Â  Â  .typing .dot { animation: blink 1s infinite; }
Â  Â  .typing .dot:nth-child(2) { animation-delay: 0.2s; }
Â  Â  .typing .dot:nth-child(3) { animation-delay: 0.4s; }

Â  Â  /* â€”â€”â€”â€”â€” Input bar with attachment pill â€”â€”â€”â€”â€” */
Â  Â  form {
Â  Â  Â  margin-top: 12px;
Â  Â  Â  width: 90%;
Â  Â  }

Â  Â  .input-group {
Â  Â  Â  display: flex;
Â  Â  Â  flex-direction: column;
Â  Â  Â  gap: 6px;
Â  Â  }

Â  Â  .attachment-pill {
Â  Â  Â  display: none;
Â  Â  Â  align-items: center;
Â  Â  Â  gap: 6px;
Â  Â  Â  background: #eef0f3;
Â  Â  Â  border: 1px solid var(--border);
Â  Â  Â  border-radius: 12px;
Â  Â  Â  padding: 4px 8px;
Â  Â  Â  font-size: 0.9em;
Â  Â  Â  color: #333;
Â  Â  }

Â  Â  .attachment-pill button {
Â  Â  Â  background: none;
Â  Â  Â  border: none;
Â  Â  Â  font-size: 1em;
Â  Â  Â  cursor: pointer;
Â  Â  Â  color: #666;
Â  Â  Â  line-height: 1;
Â  Â  }

Â  Â  .input-row {
Â  Â  Â  position: relative;
Â  Â  Â  width: 100%;
Â  Â  }

Â  Â  #question {
Â  Â  Â  width: 100%;
Â  Â  Â  padding: 12px 48px 12px 12px;
Â  Â  Â  border: 1px solid var(--border);
Â  Â  Â  border-radius: 24px;
Â  Â  Â  resize: none;
Â  Â  Â  font-size: 1em;
Â  Â  Â  color: #333;
Â  Â  }

Â  Â  #file { display: none; }

Â  Â  .attach-button {
Â  Â  Â  position: absolute;
Â  Â  Â  right: 40px;
Â  Â  Â  top: 50%;
Â  Â  Â  transform: translateY(-50%);
Â  Â  Â  background: none;
Â  Â  Â  border: none;
Â  Â  Â  font-size: 1.2em;
Â  Â  Â  cursor: pointer;
Â  Â  }

Â  Â  .send-button {
Â  Â  Â  position: absolute;
Â  Â  Â  right: 8px;
Â  Â  Â  top: 50%;
Â  Â  Â  transform: translateY(-50%);
Â  Â  Â  background: none;
Â  Â  Â  border: none;
Â  Â  Â  font-size: 1.4em;
Â  Â  Â  cursor: pointer;
Â  Â  Â  color: var(--user);
Â  Â  }
Â  </style>

Â  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
Â  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.1/dist/purify.min.js"></script>
</head>

<body>
Â  <div class="suggestions-container">
Â  Â  <p>Ask me a question or pick a suggestion â€“</p>
Â  Â  <div class="suggestions">
Â  Â  Â  <div class="suggestion-item">What was the objection regarding actuarial support for the tail factor, and what response did we provide?</div>
Â  Â  Â  <div class="suggestion-item">Which objections asked for additional or missing exhibits (e.g., updated rate/rule schedules) and how were they addressed?</div>
Â  Â  Â  <div class="suggestion-item">Can you show examples of objections about loss trend selections by coverage and our supporting responses?</div>
Â  Â  Â  <div class="suggestion-item">Are there specific objection types that tend to recur when filing in Texas?</div>
Â  Â  </div>
Â  </div>

Â  <div id="chat-window"></div>

Â  <form id="chat-form">
Â  Â  <div class="input-group">
Â  Â  Â  <div id="attachment-pill" class="attachment-pill">
Â  Â  Â  Â  <span id="file-name-display"></span>
Â  Â  Â  Â  <button type="button" id="remove-file" title="Remove attachment">Ã—</button>
Â  Â  Â  </div>

Â  Â  Â  <div class="input-row">
Â  Â  Â  Â  <textarea id="question" placeholder="Type your message hereâ€¦" required></textarea>
Â  Â  Â  Â  <button type="button" class="attach-button" title="Attach PDF">ðŸ“Ž</button>
Â  Â  Â  Â  <button type="submit" class="send-button" title="Send">âž¤</button>
Â  Â  Â  </div>
Â  Â  </div>
Â  Â  <input type="file" id="file" accept=".pdf" />
Â  </form>

Â  <script>
Â  Â  marked.setOptions({ breaks: true, gfm: true });

Â  Â  // Suggestion â†’ textarea
Â  Â  document.querySelectorAll('.suggestion-item').forEach(el => {
Â  Â  Â  el.addEventListener('click', () => {
Â  Â  Â  Â  const ta = document.getElementById('question');
Â  Â  Â  Â  ta.value = el.textContent;
Â  Â  Â  Â  ta.focus();
Â  Â  Â  });
Â  Â  });

Â  Â  // File attachment logic
Â  Â  const fileInput = document.getElementById('file');
Â  Â  const attachBtn = document.querySelector('.attach-button');
Â  Â  const pill = document.getElementById('attachment-pill');
Â  Â  const fileNameSpan = document.getElementById('file-name-display');
Â  Â  const removeBtn = document.getElementById('remove-file');

Â  Â  attachBtn.addEventListener('click', () => fileInput.click());
Â  Â  fileInput.addEventListener('change', () => {
Â  Â  Â  const name = fileInput.files[0]?.name || '';
Â  Â  Â  if (name) {
Â  Â  Â  Â  fileNameSpan.textContent = name;
Â  Â  Â  Â  pill.style.display = 'flex';
Â  Â  Â  } else {
Â  Â  Â  Â  pill.style.display = 'none';
Â  Â  Â  }
Â  Â  });
Â  Â  removeBtn.addEventListener('click', () => {
Â  Â  Â  fileInput.value = '';
Â  Â  Â  pill.style.display = 'none';
Â  Â  });

Â  Â  // Enter submits, Shift+Enter inserts newline
Â  Â  const textInput = document.getElementById("question");
Â  Â  const form = document.getElementById("chat-form");
Â  Â  textInput.addEventListener("keydown", (e) => {
Â  Â  Â  if (e.key === "Enter" && !e.shiftKey) {
Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  form.requestSubmit();
Â  Â  Â  }
Â  Â  });

Â  Â  // Endpoint
Â  Â  const ENDPOINT = "https://supren.app.n8n.cloud/webhook/ca97826c-c2aa-4fb8-a30b-22165a01b93b";
Â  Â  const chatWindow = document.getElementById("chat-window");

Â  Â  let sessionId = sessionStorage.getItem("pkSessionId");
Â  Â  if (!sessionId) {
Â  Â  Â  sessionId = crypto.randomUUID();
Â  Â  Â  sessionStorage.setItem("pkSessionId", sessionId);
Â  Â  }
Â  Â  let messages = [];

Â  Â  function appendUser(text) {
Â  Â  Â  const div = document.createElement("div");
Â  Â  Â  div.className = "bubble user";
Â  Â  Â  div.textContent = text || "";
Â  Â  Â  chatWindow.appendChild(div);
Â  Â  Â  chatWindow.scrollTop = chatWindow.scrollHeight;
Â  Â  }

Â  Â  function appendTyping() {
Â  Â  Â  const div = document.createElement("div");
Â  Â  Â  div.className = "typing";
Â  Â  Â  div.innerHTML = `
Â  Â  Â  Â  <span class="dot">.</span>
Â  Â  Â  Â  <span class="dot">.</span>
Â  Â  Â  Â  <span class="dot">.</span>
Â  Â  Â  `;
Â  Â  Â  chatWindow.appendChild(div);
Â  Â  Â  chatWindow.scrollTop = chatWindow.scrollHeight;
Â  Â  Â  return div;
Â  Â  }

Â  Â  function appendAssistantResponse() {
Â  Â  Â  const div = document.createElement("div");
Â  Â  Â  div.className = "assistant-response";
Â  Â  Â  div.innerHTML = `
Â  Â  Â  Â  <div class="assistant-final"></div>
Â  Â  Â  Â  <div class="assistant-live"></div>
Â  Â  Â  `;
Â  Â  Â  chatWindow.appendChild(div);
Â  Â  Â  chatWindow.scrollTop = chatWindow.scrollHeight;
Â  Â  Â  return div;
Â  Â  }

Â  Â  /**
Â  Â  Â * Render markdown -> HTML.
Â  Â  Â * Fix the "leading bullet before some headings" by:
Â  Â  Â *Â  1) Converting any list item that contains ONLY a heading into a heading (and removing the list wrapper if empty)
Â  Â  Â *Â  2) Promoting a "heading-like" first bullet into H2 (your existing behavior)
Â  Â  Â */

Â  Â function renderMarkdownInto(el, text) {
Â  // Parse the markdown into HTML
Â  Â  Â  const rawHtml = marked.parse(text || "");
Â Â 
Â  // Sanitize the HTML and inject it into the element
Â  Â  Â  el.innerHTML = DOMPurify.sanitize(rawHtml);
Â  Â }

Â  Â  // Extract complete JSON objects from concatenated stream: {"type":"begin"...} {"type":"item"...}
Â  Â  function extractJsonObjects(buffer) {
Â  Â  Â  const objects = [];
Â  Â  Â  let start = -1, depth = 0, inString = false, escape = false;

Â  Â  Â  for (let i = 0; i < buffer.length; i++) {
Â  Â  Â  Â  const ch = buffer[i];

Â  Â  Â  Â  if (inString) {
Â  Â  Â  Â  Â  if (escape) { escape = false; continue; }
Â  Â  Â  Â  Â  if (ch === "\\") { escape = true; continue; }
Â  Â  Â  Â  Â  if (ch === "\"") { inString = false; continue; }
Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  if (ch === "\"") { inString = true; continue; }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (ch === "{") {
Â  Â  Â  Â  Â  if (depth === 0) start = i;
Â  Â  Â  Â  Â  depth++;
Â  Â  Â  Â  } else if (ch === "}") {
Â  Â  Â  Â  Â  depth--;
Â  Â  Â  Â  Â  if (depth === 0 && start !== -1) {
Â  Â  Â  Â  Â  Â  objects.push(buffer.slice(start, i + 1));
Â  Â  Â  Â  Â  Â  start = -1;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  let leftover = "";
Â  Â  Â  if (depth > 0 && start !== -1) leftover = buffer.slice(start);
Â  Â  Â  return { objects, leftover };
Â  Â  }

Â  Â  function extractAnswer(evt) {
Â  if (!evt || typeof evt !== "object") return "";
Â Â 
Â  // If this is a standard n8n stream item
Â  if (evt.type === "item" && evt.content != null) {
Â  Â  let content = evt.content;
Â  Â Â 
Â  Â  // Only try to parse if it looks like a JSON object/array (starts with { or [)
Â  Â  if (typeof content === "string" && (content.trim().startsWith('{') || content.trim().startsWith('['))) {
Â  Â  Â  try {Â 
Â  Â  Â  Â  const parsed = JSON.parse(content);
Â  Â  Â  Â  if (parsed && typeof parsed === 'object') {
Â  Â  Â  Â  Â  Â return parsed.output || parsed.answer || parsed.result || "";
Â  Â  Â  Â  }
Â  Â  Â  } catch (_) {
Â  Â  Â  Â  // Not valid JSON, just treat as string
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  // Return the content as a string, even if it's a number
Â  Â  return String(content);
Â  }
Â Â 
Â  // Fallback for non-item events (like final responses)
Â  return String(evt.output || evt.answer || evt.result || "");
}

Â  Â  // Heuristic merge: sometimes full text, sometimes delta chunks
Â  Â  function mergeStreamText(accumulated, incoming) {
Â  Â  Â  if (!incoming) return accumulated;
Â  Â  Â  const a = accumulated || "";
Â  Â  Â  const b = incoming || "";
Â  Â  Â  if (!a) return b;

Â  Â  Â  if (b.startsWith(a)) return b;

Â  Â  Â  const maxOverlap = Math.min(a.length, b.length, 120);
Â  Â  Â  for (let k = maxOverlap; k > 0; k--) {
Â  Â  Â  Â  if (a.endsWith(b.slice(0, k))) return a + b.slice(k);
Â  Â  Â  }
Â  Â  Â  return a + b;
Â  Â  }

Â  Â  // Commit completed paragraphs into "final" so they stop re-rendering
Â  Â  function splitIntoFinalAndLive(fullText, committedLen) {
Â  Â  Â  const t = fullText || "";
Â  Â  Â  if (!t) return { finalText: "", liveText: "", committedLen: 0 };

Â  Â  Â  const normalized = t.replace(/\r\n/g, "\n");
Â  Â  Â  const lastBreak = normalized.lastIndexOf("\n\n");

Â  Â  Â  let commitAt = lastBreak;
Â  Â  Â  if (commitAt < 0 && normalized.length > 220) {
Â  Â  Â  Â  commitAt = normalized.indexOf("\n");
Â  Â  Â  Â  if (commitAt < 0) commitAt = Math.min(220, normalized.length);
Â  Â  Â  }

Â  Â  Â  let newCommitted = committedLen;
Â  Â  Â  if (commitAt > 0) newCommitted = Math.max(committedLen, commitAt + 2);

Â  Â  Â  const finalText = normalized.slice(0, newCommitted);
Â  Â  Â  const liveTextÂ  = normalized.slice(newCommitted);

Â  Â  Â  return { finalText, liveText, committedLen: newCommitted };
Â  Â  }

Â  Â  // Streaming paint throttle
Â  Â  let rafScheduled = false;
Â  Â  let lastPaint = 0;
Â  Â  const PAINT_EVERY_MS = 55; // ~18fps

Â  Â  function schedulePaint(paintFn) {
Â  Â  Â  if (rafScheduled) return;
Â  Â  Â  rafScheduled = true;

Â  Â  Â  requestAnimationFrame(() => {
Â  Â  Â  Â  rafScheduled = false;

Â  Â  Â  Â  const now = performance.now();
Â  Â  Â  Â  if (now - lastPaint < PAINT_EVERY_MS) {
Â  Â  Â  Â  Â  schedulePaint(paintFn);
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  lastPaint = now;
Â  Â  Â  Â  paintFn();
Â  Â  Â  });
Â  Â  }

Â  Â  function resetFile() {
Â  Â  Â  fileInput.value = "";
Â  Â  Â  pill.style.display = 'none';
Â  Â  }

Â  Â  form.addEventListener("submit", async (e) => {
Â  Â  Â  e.preventDefault();
Â  Â  Â  const userText = textInput.value.trim();
Â  Â  Â  if (!userText) return;

Â  Â  Â  appendUser(userText);
Â  Â  Â  messages.push({ role: "user", text: userText });
Â  Â  Â  textInput.value = "";

Â  Â  Â  const fd = new FormData();
Â  Â  Â  fd.append("sessionId", sessionId);
Â  Â  Â  fd.append("messages", JSON.stringify(messages));
Â  Â  Â  fd.append("question", userText);
Â  Â  Â  if (fileInput.files.length) fd.append("data", fileInput.files[0]);

Â  Â  Â  const typing = appendTyping();
Â  Â  Â  const assistant = appendAssistantResponse();
Â  Â  Â  const finalEl = assistant.querySelector(".assistant-final");
Â  Â  Â  const liveElÂ  = assistant.querySelector(".assistant-live");

Â  Â  Â  try {
Â  Â  Â  Â  const res = await fetch(ENDPOINT, { method: "POST", body: fd });
Â  Â  Â  Â  if (!res.ok) throw new Error(`Server ${res.status}`);

Â  Â  Â  Â  const reader = res.body?.getReader?.();
Â  Â  Â  Â  if (!reader) throw new Error("No stream available");

Â  Â  Â  Â  const decoder = new TextDecoder("utf-8");
Â  Â  Â  Â  let buffer = "";

Â  Â  Â  Â  let accumulated = "";
Â  Â  Â  Â  let committedLen = 0;
Â  Â  Â  Â  let gotAny = false;

Â  Â  Â  Â  while (true) {
Â  Â  Â  Â  Â  const { value, done } = await reader.read();
Â  Â  Â  Â  Â  if (done) break;

Â  Â  Â  Â  Â  buffer += decoder.decode(value, { stream: true });

Â  Â  Â  Â  Â  const { objects, leftover } = extractJsonObjects(buffer);
Â  Â  Â  Â  Â  buffer = leftover;

Â  Â  Â  Â  Â  for (const objStr of objects) {
Â  Â  Â  Â  Â  Â  let evt;
Â  Â  Â  Â  Â  Â  try { evt = JSON.parse(objStr); } catch (_) { continue; }

Â  Â  Â  Â  Â  Â  const piece = extractAnswer(evt);
Â  Â  Â  Â  Â  Â  if (!piece) continue;

Â  Â  Â  Â  Â  Â  if (!gotAny) {
Â  Â  Â  Â  Â  Â  Â  gotAny = true;
Â  Â  Â  Â  Â  Â  Â  if (chatWindow.contains(typing)) chatWindow.removeChild(typing);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  accumulated = mergeStreamText(accumulated, piece);

Â  Â  Â  Â  Â  Â  const split = splitIntoFinalAndLive(accumulated, committedLen);
Â  Â  Â  Â  Â  Â  committedLen = split.committedLen;

Â  Â  Â  Â  Â  Â  schedulePaint(() => {
Â  Â  Â  Â  Â  Â  Â  if (split.finalText) renderMarkdownInto(finalEl, split.finalText);
Â  Â  Â  Â  Â  Â  Â  renderMarkdownInto(liveEl, split.liveText);
Â  Â  Â  Â  Â  Â  Â  chatWindow.scrollTop = chatWindow.scrollHeight;
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (chatWindow.contains(typing)) chatWindow.removeChild(typing);

Â  Â  Â  Â  const stored = (accumulated || "").trim() || "No response received";
Â  Â  Â  Â  renderMarkdownInto(finalEl, stored);
Â  Â  Â  Â  liveEl.innerHTML = "";
Â  Â  Â  Â  messages.push({ role: "assistant", text: stored });
Â  Â  Â  Â  resetFile();

Â  Â  Â  } catch (err) {
Â  Â  Â  Â  if (chatWindow.contains(typing)) chatWindow.removeChild(typing);
Â  Â  Â  Â  finalEl.textContent = `Error: ${err.message}`;
Â  Â  Â  }
Â  Â  });
Â  </script>
</body>
</html>
